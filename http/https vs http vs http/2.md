http2
# 二进制分帧层 
HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有的传输的信息分割为更小的消息和帧，并采用二进制格式对它们进行编码

# 服务端推送
HTTP/2 新增的另一个强大的功能是服务端可以对一个客户端请求发送多个响应。换句话说，服务端可以先于客户端检测到将要请求的资源，提前推送到客户端，不发送所有资源的实体，只发送资源的 URL。客户端接到后会进行验证缓存，如果发现需要这些资源，则正式发起请求

# 标头压缩
在 HTTP/1.x 中，这些元数据始终以纯文本形式，通常会给每个传输增加 500 - 800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提高性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：

# HPACK 压缩格式压缩请求和响应标头元数据
支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小；
客户端和服务端之间同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），对相同请求而言不需要再次发送和响应，比如 User-Agent

# 多路复用
每个 TCP 连接智能发送一个请求，HTTP/1.x 在前面的请求没有完成前，后面的请求将会阻塞
HTTP/2 的出现又让我们省掉不少麻烦。多路复用允许同时通过单一 HTTP 请求多个响应

# Etag 
浏览器下次请求后会自动在 If-None-Match HTTP 请求头内提供 ETag，服务器根据这个哈希值与服务器本地对应资源当前的哈希进行比对。如果它未发生变化，服务器将返回 304 Not Modified 相应。这样一个来回避免了浏览器再次去请求资源，省钱又省时间

304 not modified  

301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；
302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

  从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。
  比如说，有的时候A 网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。302重定向所造成的网址URL劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。