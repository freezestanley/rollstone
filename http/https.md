# HTTP 为什么不安全

1.通信是采用明文（不加密），内容可能被窃听
从图中我们可以看出，我们作为客户端处于庞大互联网中的一个节点，而在通信时，中间会经历很多个阶段，而每个阶段报文内容都有可能会被窃听
2.无法验证接受报文的完整性，可能已被篡改
无法验证完整性，即意味着接收到的报文可能是缺失的，也意味着接收到的报文可能是错误的，也就是不是我们想要的。
3.HTTP 协议不验证通信方身份，因此可能被伪装
HTTP 协议设计的十分简单，并且不验证通信双方，也就意味着，不论是谁发送的请求，只要合法（后台没有限制访问 ip 和端口号），服务器都会接受，而不确认通信方身份可能会导致以下的问题：

无法确定请求发送至目标 Web 服务器是否按照真实意图返回响应的那台服务器，有可能是已经伪装的 Web 服务器
无法确定响应返回到的客户端是否是按照真实意图接收响应的客户端，有可能是已伪装的客户端
无法确定正在通信的对方是否具有访问权限，因为某些 Web 服务器上保存着重要信息，只想发给特定用户通信的权限
无法判断请求是来自何方，出自谁手
即是无意义的请求也照单全收，无法阻止海量请求下的 DoS 攻击（Denial of Service），也就容易遭受攻击

# HTTPS 实现原理
HTTPS 本质也是基于 HTTP 协议的
通用接口部分使用 SSL(Secure Socket Layer) 和 TLS(Transport Layer Security) 协议代替
HTTPS是披着 SSL 协议外壳的 HTTP 协议。
HTTPS = HTTP + 加密 + 证书 + 完整性保护

数据传输阶段（对称密钥加密）
公开密钥加密（Public-key cryptography）解决了上述的发送密钥问题。它采用一对非对称的密钥，一把公钥一把私钥。加密过程就是，发送加密报文的一方是用对方的公开密钥进行加密，接收方式用自己本地的私钥进行解密，也就是说发送方并不需要附带着发送用来解密的密钥，这种方式就不需要考虑密钥在传输过程中被攻击这获取到。

私钥和公钥是一对多的关系，公钥可以随意转发，只要采用公钥加密的报文，都只能使用对应私钥进行解密

# 混合验证机制
HTTPS 采用的是混合加密
原因是，非对称加密相比对称加密更加复杂，效率更低，在前端业务中一般都是存在大量的 HTTP 请求，所以非对称加密的低效是无法被接受的。
此外，非对称加密的场景只在服务端保存私钥，也就是说一对公私钥只能单向传输数据，
因此可以用来确认通信安全以及服务端返回证书。确认安全之后，传输数据采用的就是速度更快的对称加密

# 证书 数字证书认证机构（CA）

# 数据完整性
确保数据完整性，也就意味着数据安全没有被第三方篡改，这时候就需要通过 数字签名
数字签名是一段由发送者生成的特殊加密校验码，用于传输过程中确认报文的完整性。数字签名涉及到了两种技术：非对称加密 和 数字摘要。生成数字摘要的算法通过 MD5 和 SHA 这种不可逆算法，将不定长的报文内容提取出定长的数字摘要

数字签名的整个签名和校验过程分为五步
多说一句，对于本地存储，无论是服务端的私钥还是客户端的随机数，都不是 HTTPS 通信过程的安全考虑，HTTPS 只保证在网络传输过程的数据安全性，本地的内容安全不被窃取依靠的是防火墙，杀毒软件等等。

```mermaid
graph BR

服务端公钥 --> 数字签名机构用私钥对公钥签名
客户端https --> 服务端建立SSL/TSL链接 --> 将公钥和证书返回给客户端 --> 客户端用认证公钥对证书签名确认公钥的真实性，生成通讯密钥 然后用公钥加密返回给服务端 --> 服务端私钥对加密数据进行非对称解密得到密钥

```

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9764c14ed2fd4553a535a20c5c839664~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?"/>

（1）第一步:客户机的TCP首先向服务器的TCP发送连接请求报文段。这个特殊报文段的首部中的同步位SYN置1,同时选择一个初始序号seq=J。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。 这时，TCP客户进程进入SYN-SENT (同步已发送)状态。
（2）第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该TCP连接分配缓存和变量。在确认报文段中，把SYN位和ACK位都置1,确认号是ack=J+1,同时也为自己选择一个初始序号 seq=K。同时，确认报文段也不能携带数据，但也要消耗掉一个序号。这时，TCP服务器进程进入SYN-RCVD (同步收到)状态。
（3）第三步:当客户机收到确认报文段后，还要向服务器给出确认，并为该TCP连接分配缓存和变量。确认报文段的ACK位置1,确认号ack=y+ 1,序号seq=x+ 1。该报文段可以携带数据，若不携带数据则不消耗序号。这时，TCP客户进程进入ESTABLISHED (已建立连接)状态。
成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。
但是，这时候有一个问题就是，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。
SYN洪泛攻击指的是攻击者给目标服务器发送大量的SYN消息，服务器会发送SYN/ACK并等待攻击者的ACK消息，这时服务器上会为此连接占用一定资源。如果攻击者通过篡改包中的源IP或在Client端过滤相应包等方式使目标服务器一直收不到ACK消息，这时服务器上会保持大量的半连接，这些半连接占用的资源会通过一个超时机制来释放，如果攻击者发送的包数量巨大，服务器来不及回收资源，则会出现资源耗尽从而无法响应新的正常请求。
SYN cookie可以有效抵御SYN洪泛攻击，洪泛攻击也还有其他几种方式，具体原理这里就不再过多介绍


链接：https://juejin.cn/post/7098335747266052132
