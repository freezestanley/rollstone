# add(1)(2)(3)
```
function currying(fn){ 
  var allArgs = []; 
  return function next(){ 
    var args = [].slice.call(arguments); 
    if(args.length > 0){ 
      allArgs = allArgs.concat(args); 
      return next; 
    } else { 
      return fn.apply(null, allArgs); 
    } 
  } 
}
var add = currying(
  function(){ 
    var sum = 0; 
    for(var i = 0; i < arguments.length; i++){ 
      sum += arguments[i]; 
    }
    return sum;
});
```
```
function add () {
  var list = [...arguments]
  const p = function () {
    list = [...list, ...arguments]
    return p
  }
  p.toString = function () {
    return list.reduce((pre,curr) => {
      return pre+curr
    }, 0)
  }
  p.valueOf = function () {
    return list.reduce((pre,curr) => {
      debugger
      return pre+curr
    }, 0)
  }
  return p
}
```

# new
new 做了哪些事
     创建一个空的简单JavaScript对象（即{}）；
     为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；
     将步骤1新创建的对象作为this的上下文 ；
     如果该函数没有返回对象，则返回this。
```
function _new(ctor, ...args) {
  if(typeof ctor !== 'function'){
    throw 'ctor must be a function';
  }
  let obj = new Object();
  obj.__proto__ = Object.create(ctor.prototype)
  let res = ctor.apply(obj, [...args]); 
  return obj;
}

function demo(name){
  this.name = name
}
demo.prototype.sayhi = function () {
  return this.name
}
let dd = _new(demo,'nike')
```
每个对象实例创建的时候都会有一个内部属性__proto__，指向这个函数的原型对象，__proto__会有浏览器兼容性问题，同时在mdn上被标记已经废弃，大家不要在生产环境上使用

# 手写发布订阅

```
class EventEmitter {
  events: {[key:string]:Function[]} = {}
  on(type: string, callback: Function){
    if(!this.events)
      this.events = Object.create(null)
    
    if(!this.events[type]){
      this.events[type] = [callback]
    } else {
      this.events[type].push(callback)
    }
  }
  off(type:string){
    if(!this.events[type]) return
    delete this.events[type]
  }
  once(type:string, callback: Function) {
    function fn(){
      callback()
      this.off(type)
    }
    this.on(type,fn)
  }
  emit(type:string, ...rest) {
    this.events[type] && this.events[type].forEach(fn=> fn(...rest))
  }
}

const event = new EventEmitter()
event.on('click', (...rest) => {
  console.log(rest)
})
event.emit('click')
event.off('click')
event.once('click', (...rest) => {
  console.log(rest)
})
```
1.新建一个类
2.类生成一个[]来收集事件
3.emit once on 3个方法 
on 监听 once 监听一次 emit 触发

# instanceOf
```
function _instanceof(leftObj: object, rightObj: object): boolean {
  let rightProto = right.prototype // 右值取原型
  leftObj = leftObj.__proto__ // 左值取 __proto__
  while(true) {
    if(leftObj === null) return false
    else if(leftObj === rightProto) return true
    leftObj = leftObj.__proto__
  }
}
```

# bind

```
Function.prototype.bind = function(context) {
  var self= this
  var args = [...arguments].slice(1)
  var tmp = function (){}
  var resFn = function(){
    return self.apply(this instanceof resFn ? this : context, [...args, ...arguments] )
  }
  tmp.prototype = this.prototype
  resFn.prototype = new tmp()
  return resFn
}
```

# debounce

```
function debounce (fn, delay){
  let timer = number || null
  return function (){
    if (timer) window.clearTimeout(timer)
    timer = window.setTimeout(function(){
      fn()
    }, delay)
  }
}
```

# throttle

```
function throttle (fn, delay) {
  let flag = true
  return function (){
    if (!flag) return
    flag = false
    setTimeout(function(){
      fn()
      flag = true
    }, delay)
  }
}
```

# call & apply

```
Function.prototype.call = function (context = window){
    const args = [...arguments].slice(1)
    context.fn = this
    const result = context.fn(...args)
    delete context.fn
    return result
}

Function.prototype.apply = function(context = window) {
  const args = arguments[1]
  context.fn = this
  const result = args? context.fn(...args) : context.fn() 
  delete context.fn
  return result
}
```

# 浅拷贝

```
function cloneShallow(source) {
  var target = {}
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key){
      target[key] = source[key]
    })
  }
  return target
}
```