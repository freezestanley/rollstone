乾坤
shadow dom 会隔离 css 以及利用 document 不会找到里面的 dom，但是对于 js 脚本而已并没有做到绝对的隔离，比如 window.setInterval 等里面的方法以及属性还是会与外界相互影响，此时乾坤框架 createSandbox 实现了对脚本的隔离。
沙箱分为 3 种：
1：singular=true,如果是单一应用切换则用 LegacySandbox，
2：singular=false, 如果一个页面包含多个子应用则用 ProxySandbox
3：如果浏览器不支持 window.Proxy，则兼容用 SnapshotSandbox

> ProxySandbox - 多子应用情况
> 1: fakewindow + window 的组合，每次 new ProxySandbox() 会创建 fakewindow 实例作为 proxy
> 2：set 时值放到 fakewindow 里面，get 时先从 fakewindow 里面取，取不到就到 window 里面取
> 2：判断是特殊属性比如不可配置，编辑，修改的属性，就直接从 window 里面取

```
export default class ProxySandbox implements SandBox {
    /** window 值变更记录 */
    private updatedValueSet = new Set<PropertyKey>();
    name: string;
    type: SandBoxType;
    proxy: WindowProxy;
    sandboxRunning = true; // 沙箱状态
    active() {
      // 记录激活的沙箱数量
      if (!this.sandboxRunning) activeSandboxCount++;
      this.sandboxRunning = true;
    }
    inactive() {
      .........
      this.sandboxRunning = false;
    }

    constructor(name: string) {
      // 变量配置，这里rowWindow = window
       .........
      // 将不可编辑的特殊属性记录到propertiesWithGetter
      const { fakeWindow, propertiesWithGetter } = createFakeWindow(rawWindow);
      .........

      const proxy = new Proxy(fakeWindow, {
        set(target: FakeWindow, p: PropertyKey, value: any): boolean {
          // 如果本实例的沙箱正在运行
          if (self.sandboxRunning) {
            .........
            // @ts-ignore
            target[p] = value;
            // 记录修改的值
            updatedValueSet.add(p);
            .........
          }
          .........
          // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误
          return true;
        },

        get(target: FakeWindow, p: PropertyKey): any {
            // 一些特殊属性，如[window,self,top,hasOwnProperty,document] 的特殊处理以及返回
            .........

          // eslint-disable-next-line no-bitwise
          // 有getter的属性，直接访问window.p, 否则访问fakewindow.p
          // 如果没有不可编辑且具有getter的属性，就先从fakewindow里面取，取不到就从window里面取
          const value = propertiesWithGetter.has(p) ? (rawWindow as any)[p] : (target as any)[p] || (rawWindow as any)[p];

          return getTargetValue(rawWindow, value);
        },

        // trap in operator
        // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#L12
        has() {},
        // 获取 FakeWindow || window 里面的自有属性
        getOwnPropertyDescriptor() {}

        // trap to support iterator with sandbox
        // FakeWindow + window 里面的不重复的属性canvcat
        ownKeys() {}
        // 首先看这个属性是从哪来的，从window里面来的就在window定义
        defineProperty() {},
        // 这里只删除 fakeWindow里面的属性
        deleteProperty() {},
      });

      this.proxy = proxy;
    }
  }
```

![avatar](https://github.com/freezestanley/rollstone/blob/main/%E5%85%B6%E4%BB%96/diff/a.png)
